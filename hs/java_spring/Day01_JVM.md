## JVM이 정확히 무엇이고, 어떤 기능을 하나요?

__개념__<br/>
Java Virtual Machine의 약자로, 자바 프로그램이 실행되는 환경을 제공하는 가상 컴퓨터입니다.<br/>
JVM은 자바 프로그램이 다양한 운영체제와 하드웨어에 독립적으로 실행될 수 있도록 합니다.

__기능__<br/>
1. 메모리 관리<br/>
    JVM은 힙, 스택, 메소드 영역, 프로그램 카운터 등의 메모리 영역을 관리합니다.
2. 가비지 컬렉션(GC, Garbage Collection)<br/>
    사용되지 않은 객체를 자동으로 메모리에서 해제하여 메모리 누수를 방지합니다.
3. 컴파일<br/>
    바이트 코드(.class)를 기계어로 변환하여 실행합니다. 이 과정에서 JIT(Just-In-Time) 컴파일러가 사용됩니다.

__동작 원리__<br/>
<img src="https://github.com/chunghye98/KB_CS_Study/assets/57451700/be8f4003-26a3-4fc2-b7cf-cc003e4b3b1c" width="300px">

1. 자바 클래스 로더(Class Loader)가 바이트코드 파일(.class)을 JVM의 런타임 데이터 영역(Runtime Data Areas) 로드합니다.
2. JVM은 바이트 코드를 `Linking` 합니다. 이 단계는 다음과 같이 세 단계로 나눌 수 있습니다.
    1. **검증**(Verifying): 바이트코드가 자바 언어 명세 및 JVM 명세에 명시된 대로 잘 구성되어 있는지 검사합니다.
    2. **준비**(Preparing): static 변수를 각 유형의 기본값으로 초기화합니다. 예를 들어, int 타입은 0으로, reference 타입은 null로 초기화합니다.
    3. **분석**(Resolving): 심볼릭 레퍼런스(ex. 메서드명, 클래스명, 필드명)를 실제 메모리 레퍼런스로 변환합니다.
    4. **초기화**(Initializing): 클래스 초기화 함수와 클래스에 작성된 static 초기화 함수를 모두 합쳐 실행합니다.
3. 실행 엔진을 통해 바이트 코드가 실행됩니다. 실행 엔진은 바이트코드를 기계어로 컴파일해야 하며, 그 방식은 다음 두 가지가 있습니다.
    1. **인터프리터**: 바이트 코드 명령어를 하나씩 읽어서 해설하고 실행합니다. 기본적으로 이 방식으로 동작합니다. 
    2. **JIT(Just-In-Time) 컴파일러**: 바이트코드 전체를 컴파일하고 이후에는 해당 메서드를 컴파일된 언어로 직접 실행하는 방식입니다. 캐시에 보관하기 때문에 한 번 컴파일된 코드는 계속 빠르게 수행됩니다. 따라서, 한 번만 실행되는 코드는 인터프리터를 사용하고, 자주 사용하는 메서드는 JIT 컴파일러를 사용합니다. 

__JVM의 Runtime Data Area__<br/>
<img src="https://github.com/VSFe/Tech-Interview/assets/57451700/395d8d07-61a5-4ef7-a925-114d0600b84f" width="300px">

자바 프로그램이 실행되는 동안 JVM이 관리하는 메모리 구조입니다.

1. **메소드 영역**<br/>
    모든 스레드가 공요하는 영역으로, JVM이 로드한 각 클래스 또는 인터페이스에 대한 정보가 저장됩니다. 이 정보에는 변수, 메서드, static 변수, 인터페이스 등이 포함됩니다.
    - **런타임 상수 풀**<br/>
        각 클래스와 인터페이스의 상수뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블입니다. 즉, 어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조합니다. 
2. **힙(Heap)**<br/>
    인스턴스 또는 객체를 저장하는 공간으로 GC의 관리 대상입니다.
3. **스택(Stack)**<br/>
    각 스레드마다 별도로 존재하며, 메서드 호출 시마다 프레임이 생성됩니다. 한 프레임마다 지역 변수, 파라미터, 반환 값, 연산 중간 값이 저장됩니다.
4. **프로그램 카운터(Program Counter, PC)**<br/>
    각 스레드마다 별도로 존재하며, JVM 명령어의 현재 위치를 가리키는 레지스터입니다.
5. **Native Method Stack**<br/>
    자바 언어 외의 언어로 작성된 네이티브 코드를 위한 스택입니다.

### 자바 말고 다른 언어는 JVM 위에 올릴 수 있나요?
가능합니다.<br/>
JVM은 자바 바이트 코드를 실행하는 가상 머신이기 때문에 자바 바이트 코드로 변환될 수 있는 언어는 JVM 위에서 동작 가능합니다. <br/>
예를 들어, Kotlin, Groovy 등의 언어가 있습니다.

### JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?
가능합니다.<br/>
각 언어는 자신만의 컴파일러를 가지고 있으며, 이 컴파일러로 소스 코드를 자바 바이트 코드로 변환할 수 있습니다. 

### VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.
장점으로는 하드웨어나 OS에 독립적으로 사용할 수 있다는 점이 있습니다. 플랫폼에 독립적이기 때문에 대중적인 프로그램을 만들 경우 적합합니다.<br/>
단점으로는 성능 오버헤드가 발생할 수 있다는 점이 있습니다. 직접 실행하는 것보다 계층이 하나 더 추가되기 때문에 더 좋은 성능을 바라는 경우 적합하지 않을 수 있습니다.

### JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?
아닙니다.<br/>
프로세스는 부모 프로세스에서 `fork`하여 자식 프로세스가 생성됩니다. 이와 같은 관점에서 바라봤을 때, JVM은 바이트 코드를 실행하기 좋게 기계어로 변환하고 실행할 뿐 프로그램을 만드는 것이 아니기 때문입니다.


### 참고
[JVM Internal](https://d2.naver.com/helloworld/1230)<br/>
[JVM 구조와 JAVA의 동작 원리](https://velog.io/@sgwon1996/JAVA%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC%EC%99%80-JVM-%EA%B5%AC%EC%A1%B0)
