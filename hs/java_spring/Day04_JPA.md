## JPA와 같은 ORM을 사용하는 이유가 무엇인가요?

ORM(Object-Relational Mapping)은 데이터베이스와 객체 지향 프로그래밍 언어 간의 불일치를 해결하기 위해 사용하는 기술입니다. ORM을 사용하면 다음과 같은 장점이 있습니다.
1. 생산성 향상<br/>
   SQL 쿼리를 직접 사용할 필요 없이 객체지향 코드로 데이터베이스 작업을 수행할 수 있기 때문에 개발자의 생산성이 향상됩니다.
2. 유지보수성 향상<br/>
   데이터베이스 테이블 구조가 변경되더라도 ORM 매핑을 통해 쉽게 대응할 수 있습니다.


### 영속성은 어떤 기능을 하나요? 이게 진짜 성능 향상에 큰 도움이 되나요?

__영속성__<br/>
영속성이란 데이터를 생성한 프로그램이 종료되어도 사라지지 않는 데이터의 특성을 의미합니다. 영속성을 갖지 않으면 데이터는 메모리에서만 존재하게 되고 프로그램이 종료되면 해당 데이터는 모두 사라지게 됩니다. 따라서 데이터를 파일이나 DB에 영구 저장함으로써 데이터에 영속성을 부여해야 합니다.

__영속성 컨텍스트__<br/>
JPA에서 엔티티를 영구 저장하고 관리하는 작업을 수행하는 공간입니다. 엔티티 매니저가 영속성 컨텍스트를 생성하여 사용합니다. 애플리케이션과 DB 사이에서 동작하는 하나의 추상 계층이라고 볼 수 있습니다.
영속성 컨텍스는 기본적으로 트랜잭션 범위에서 동작합니다. 같은 트랜잭션 내에서는 동일한 엔티티 매니저가 영속성 컨텍스트를 공유하고, 엔티티의 변경을 관리합니다.

![](https://incheol-jung.gitbook.io/~gitbook/image?url=https%3A%2F%2F2649832514-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-M5HOStxvx-Jr0fqZhyW%252F-MHb8Kq2OMRiS2HyXT_K%252F-MHbBcxqMRck0E9YERLA%252FJPA_3_7.png%3Falt%3Dmedia%26token%3Df8c834cf-8ced-4e70-82d2-5ecfec518af6&width=768&dpr=1&quality=100&sign=b551b47e&sv=1)

__영속성 컨텍스트의 장점__<br/>
1. 1차 캐시<br/>
   영속성 컨텍스트는 1차 캐시로 작동합니다. 즉, 영속성 컨텍스트 내에서 조회된 엔티티는 메모리에 저장되어 동일한 트랜잭션 내에서 반복 조회 시 데이터베이스에 다시 접근하지 않고 캐시된 엔티티를 반환합니다. 이는 데이터베이스 접근 횟수를 줄여 성능을 향상시킵니다. 
2. 지연 로딩<br/>
   관계형 데이터를 필요할 때까지 로딩하지 않고 지연 로딩을 통해 성능을 최적화할 수 있습니다.
3. 변경 감지(더티 체킹)<br/>
   영속성 컨텍스트는 엔티티 객체의 상태 변화를 자동으로 감지하여 트랜잭션 종료 시점에 DB에 반영(commit)합니다.    
   이때, 엔티티가 처음 영속성 컨텍스트에 추가될 때 엔티티의 현재 상태(필드 값)를 스냅샷으로 저장합니다. 플러시 시점에 스냅샷과 현재 엔티티를 비교해서 변경된 부분을 찾고, 변경된 데이터가 있다면 update 쿼리문을 쓰기 지연 SQL 저장소에 저장해 두었다가 트랜잭션 커밋 시 DB에 반영합니다.
> flush: 엔티티의 변경 사항을 DB에 반영하지만, 트랜잭션이 커밋되지 않았기 때문에 다른 트랜잭션에서는 보이지 않습니다. 

__단점__<br/>
1. 지연로딩을 적절히 관리하지 않으면 N+1 쿼리 문제 등 성능 이슈가 발생할 수 있습니다.
2. 복잡한 쿼리나 대규모 배치 작업은 JPQL보다는 native SQL 쿼리가 더 효율적일 수 있습니다. 

### N + 1 문제에 대해 설명해 주세요.
JPA의 지연로딩으로 인해 발생할 수 있는 문제입니다. 연관 관계가 설정된 엔티티를 조회할 경우에 조회한 데이터 갯수(n)만큼 연관관계의 조회 쿼리가 발생하는 문제를 말합니다. 

이는 관계형 데이터베이스와 객체지향 언어 간의 패러다임 차이로 인해 발생합니다. 객체는 연관관계를 통해 레퍼런스를 가지고 있으면 언제든지 메모리 내에서 접근 가능하지만 DB의 경우 Select 쿼리를 통해서만 조회할 수 있기 때문입니다. 

이를 해결하기 위해 즉시 로딩, batch fetch 등의 기법을 사용하여 쿼리 수를 줄이고 성능을 최적화할 수 있습니다. 

### 참고
[JPA의 이해와 실제 사용 시 고려사항](https://f-lab.kr/insight/understanding-jpa)    
[영속성 컨텍스트에 대해 질문이 있습니다.](https://www.google.com/search?q=%EC%98%81%EC%86%8D%EC%84%B1+%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8&oq=%EC%98%81%EC%86%8D%EC%84%B1+%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8&gs_lcrp=EgZjaHJvbWUyBggAEEUYOTIGCAEQRRg80gEIMzI0MmowajeoAgCwAgA&sourceid=chrome&ie=UTF-8#ip=1)    
[영속성 컨텍스트(Persistence Context)](https://incheol-jung.gitbook.io/docs/q-and-a/spring/persistence-context)
